<!DOCType html>
<html>

<head>
    <script>
        // Primitive Data types in JS:
        // In JavaScript, a primitive (primitive value, primitive data type) is data that is not an object and has no methods. There are 7 primitive data types: string, number, bigint, boolean, undefined, symbol, and null.
        //https://developer.mozilla.org/en-US/docs/Glossary/Primitive

        //Symbols:
        //Symbol is a built-in object whose constructor returns a symbol primitive — also called a Symbol value or just a Symbol — that’s guaranteed to be unique. 
        //Symbols are often used to add unique property keys to an object that won’t collide with keys any other code might add to the object, and which are hidden from any mechanisms other code will typically use to access the object.
        //Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
        //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
        //https://javascript.info/symbol
        //https://www.javascripttutorial.net/es6/symbol/

        let sym1 = Symbol();
        let sym2 = Symbol();
        let sym3 = Symbol("For Users ID"); // Symbol with given DESCRIPTION (Not affect the valu

        console.log(sym1); //Symbols don’t auto-convert to a string
        console.log(sym2);
        console.log(sym3);

        console.log(sym1 == sym2); //false
        console.log(typeof sym1); // symbol

        let id1 = Symbol("id");
        let id2 = Symbol("id");

        console.log(id1 == id2); // false

        // Exanmple 1:
        var studentsArr = [{
            id: 1,
            uID: Symbol(),
            name: 'Ali',
            faculty: 'FCI'
        }, {
            id: 2,
            uID: Symbol(),
            name: 'Ahmed',
            faculty: 'Sci'
        }, {
            id: 3,
            uID: Symbol(),
            name: 'xyz',
            faculty: 'Eng'
        }];

        studentsArr.push({
            id: 3,
            uID: Symbol(),
            name: 'aa',
            faculty: 'sci'
        });

        console.log(studentsArr[1]);
        console.log(studentsArr[2].uID == studentsArr[3].uID); //false

        let srchStd = studentsArr.find(std => std.name == "aa");
        let srchStdUID = srchStd.uID;

        let srchStdObj = studentsArr.find(std => std.uID == srchStdUID);
        console.log(srchStdObj);
        //////////////////

        //Example 2:
        let statuses = {
            OPEN: Symbol('Open'),
            IN_PROGRESS: Symbol('In progress'),
            COMPLETED: Symbol('Completed'),
            HOLD: Symbol('On hold'),
            CANCELED: Symbol('Canceled')
        };


        //Global symbols
        //https://javascript.info/symbol#global-symbols
        //usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
        //there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
        //In order to read (create if absent) a symbol from the registry, use Symbol.for(key).

        // read from the global registry
        // if the symbol for KEY = id not exist, it is created
        let id = Symbol.for("GlobalStatus"); // Will create new symbol for Key: id

        // read it again (maybe from another part of the code)
        let idAgain = Symbol.for("GlobalStatus"); // will retrun the same symbol value for key: id

        // the same symbol
        console.log(id === idAgain); // true

        /*
        Summary:
            //https://javascript.info/symbol#summary
            Symbol is a primitive type for unique identifiers.

            Symbols are created with Symbol() call with an optional description (name).

            Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.

            Symbols have two main use cases:

            “Hidden” object properties. If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.

            So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.

            There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors.
        */
    </script>

    <head>

        <body>

        </body>

</html>